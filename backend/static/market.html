<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Market Detail</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, sans-serif; background: #f7f8fa; color: #1a1a1a; }

    /* Back link */
    .back {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 16px 32px; font-size: 14px; color: #555; text-decoration: none;
      background: #fff; width: 100%; border-bottom: 1px solid #e5e5e5;
    }
    .back:hover { color: #111; }

    /* Layout */
    .layout {
      max-width: 1000px; margin: 24px auto; padding: 0 20px;
      display: grid; grid-template-columns: 1fr 320px; gap: 24px; align-items: start;
    }
    @media (max-width: 760px) { .layout { grid-template-columns: 1fr; } }

    /* Event header */
    .event-header {
      background: #fff; border-radius: 16px; padding: 24px;
      border: 1px solid #e8e8e8; margin-bottom: 20px;
    }
    .event-top { display: flex; align-items: center; gap: 16px; margin-bottom: 12px; }
    .event-icon {
      width: 56px; height: 56px; border-radius: 14px; background: #f0f0f5;
      display: flex; align-items: center; justify-content: center; font-size: 28px;
    }
    .event-title { font-size: 22px; font-weight: 700; }
    .event-meta {
      display: flex; align-items: center; gap: 16px; flex-wrap: wrap;
    }
    .event-meta-item { font-size: 13px; color: #888; display: flex; align-items: center; gap: 4px; }
    .platform-icons { display: flex; gap: 4px; }
    .platform-icon {
      width: 22px; height: 22px; border-radius: 50%; overflow: hidden; flex-shrink: 0;
    }
    .platform-icon img { width: 100%; height: 100%; object-fit: cover; }

    /* Outcomes table */
    .outcomes-section {
      background: #fff; border-radius: 16px; padding: 24px;
      border: 1px solid #e8e8e8;
    }
    .outcomes-table { width: 100%; border-collapse: collapse; }
    .outcomes-table th {
      text-align: left; font-size: 11px; color: #999; text-transform: uppercase;
      letter-spacing: 0.5px; padding: 0 12px 12px; font-weight: 600;
    }
    .outcomes-table th:nth-child(3),
    .outcomes-table th:nth-child(4) { text-align: center; }
    .outcomes-table td { padding: 14px 12px; border-top: 1px solid #f0f0f0; }
    .outcome-cell { display: flex; align-items: center; gap: 10px; }
    .outcome-cell .platform-icons { margin-left: 4px; }
    .pct-cell { font-size: 18px; font-weight: 700; }
    .buy-btn {
      padding: 10px 18px; border-radius: 8px; font-size: 13px; font-weight: 600;
      border: none; cursor: pointer; min-width: 44px; min-height: 44px;
      transition: background .15s;
    }
    .buy-yes { background: #dcfce7; color: #16a34a; }
    .buy-yes:hover { background: #bbf7d0; }
    .buy-no { background: #fee2e2; color: #dc2626; }
    .buy-no:hover { background: #fecaca; }

    /* Order book tabs */
    .tabs {
      display: flex; gap: 0; margin-bottom: 20px; border-bottom: 1px solid #e8e8e8;
    }
    .tabs-right { margin-left: auto; display: flex; }
    .tab {
      padding: 10px 14px; font-size: 12px; color: #888; cursor: pointer;
      border-bottom: 2px solid transparent; font-weight: 500;
      background: none; border-top: none; border-left: none; border-right: none;
    }
    .tab.active { color: #111; border-bottom-color: #6366f1; font-weight: 600; }
    .tab:hover { color: #111; }

    .outcome-active td { background: #f7f8fa; }

    .book-inline {
      padding: 16px 4px; border-top: 1px solid #f0f0f0;
    }

    .book-section {
      background: #fff; border-radius: 16px; padding: 24px;
      border: 1px solid #e8e8e8; margin-top: 20px;
    }
    .book-table { width: 100%; border-collapse: collapse; }
    .book-table th {
      text-align: right; font-size: 11px; color: #999; text-transform: uppercase;
      padding: 0 8px 10px; font-weight: 600;
    }
    .book-table th:first-child { text-align: left; }
    .book-table td { padding: 8px; text-align: right; font-size: 14px; border-top: 1px solid #f7f7f7; }
    .book-table td:first-child { text-align: left; }
    .price-ask { color: #dc2626; font-weight: 600; }
    .price-bid { color: #16a34a; font-weight: 600; }
    .book-divider {
      text-align: center; padding: 10px; font-size: 13px; color: #888;
      border-top: 1px solid #f0f0f0; border-bottom: 1px solid #f0f0f0;
    }
    .book-divider span { color: #16a34a; }

    /* Right panel - Buy */
    .buy-panel {
      background: #fff; border-radius: 16px; padding: 24px;
      border: 1px solid #e8e8e8; position: sticky; top: 24px;
    }
    .panel-header {
      display: flex; align-items: center; gap: 10px;
      margin-bottom: 20px; font-size: 16px; font-weight: 700;
    }
    .panel-icon {
      width: 32px; height: 32px; border-radius: 8px; background: #f0f0f5;
      display: flex; align-items: center; justify-content: center; font-size: 16px;
    }

    .panel-tabs { display: flex; margin-bottom: 20px; border-bottom: 1px solid #e8e8e8; }
    .panel-tab {
      flex: 1; text-align: center; padding: 10px; font-size: 14px; font-weight: 500;
      color: #888; cursor: pointer; border-bottom: 2px solid transparent;
      background: none; border-top: none; border-left: none; border-right: none;
    }
    .panel-tab.active { color: #111; border-bottom-color: #6366f1; }

    .market-prices { display: flex; gap: 10px; margin-bottom: 20px; }
    .market-price {
      flex: 1; padding: 14px; border-radius: 12px; text-align: center;
      cursor: pointer; border: 2px solid transparent;
    }
    .market-price.yes { background: #dcfce7; color: #16a34a; }
    .market-price.yes.active { border-color: #16a34a; }
    .market-price.no { background: #fee2e2; color: #dc2626; }
    .market-price.no.active { border-color: #dc2626; }
    .market-price .label { font-size: 12px; font-weight: 600; }
    .market-price .val { font-size: 22px; font-weight: 700; }

    .field-label { font-size: 13px; color: #888; margin-bottom: 6px; }
    .amount-input {
      width: 100%; padding: 14px 16px; border-radius: 10px;
      border: 1px solid #e5e5e5; font-size: 24px; font-weight: 700;
      text-align: right; margin-bottom: 8px; outline: none;
    }
    .amount-input:focus { border-color: #6366f1; }
    .balance-line {
      text-align: right; font-size: 13px; color: #888; margin-bottom: 12px;
    }
    .quick-btns { display: flex; gap: 8px; margin-bottom: 20px; }
    .quick-btn {
      flex: 1; padding: 10px; border-radius: 8px; border: 1px solid #e5e5e5;
      background: #fff; font-size: 13px; font-weight: 600; cursor: pointer;
      min-height: 44px;
    }
    .quick-btn:hover { background: #f7f8fa; }

    .route-block {
      border: 1px solid #e8e8e8; border-radius: 12px; margin-bottom: 16px; overflow: hidden;
    }
    .route-detail { padding: 12px 16px; }
    .route-row {
      display: flex; justify-content: space-between; align-items: center;
      padding: 7px 0; font-size: 13px; color: #555;
    }
    .route-row .val { font-weight: 600; color: #111; }
    .route-row .platform-dot {
      width: 18px; height: 18px; border-radius: 50%; overflow: hidden;
      display: inline-flex; align-items: center; justify-content: center;
      vertical-align: middle; margin-right: 6px;
    }
    .route-row .platform-dot img { width: 100%; height: 100%; object-fit: cover; }
    .route-empty { padding: 14px 16px; text-align: center; font-size: 13px; color: #bbb; }

    .to-win {
      display: flex; justify-content: space-between; align-items: center;
      padding: 12px 0; margin-bottom: 16px; font-size: 14px;
    }
    .to-win .label { color: #888; font-weight: 500; }
    .to-win .val { font-size: 20px; font-weight: 700; color: #16a34a; }

    .submit-btn {
      width: 100%; padding: 16px; border-radius: 12px; border: none;
      background: #16a34a; color: #fff; font-size: 16px; font-weight: 700;
      cursor: pointer; min-height: 52px; transition: background .15s;
    }
    .submit-btn:hover { background: #15803d; }
    .submit-btn:disabled { opacity: .5; cursor: default; }

    .loading { text-align: center; padding: 60px; color: #999; }

    .top-bar {
      background: #fff; border-bottom: 1px solid #e5e5e5;
      padding: 12px 32px; display: flex; align-items: center; justify-content: space-between;
    }
    .top-bar .logo { font-size: 22px; font-weight: 700; letter-spacing: -0.5px; text-decoration: none; color: #1a1a1a; }
    .top-bar .logo span { color: #6366f1; }
    .connect-btn {
      padding: 10px 20px; border-radius: 10px; border: none;
      background: #6366f1; color: #fff; font-size: 14px; font-weight: 600;
      cursor: pointer; transition: background .15s;
    }
    .connect-btn:hover { background: #4f46e5; }
    .connect-btn.connected { background: #16a34a; }
    .connect-btn.connected:hover { background: #15803d; }
  </style>
</head>
<body>

<div class="top-bar">
  <a href="/" class="logo"><span>Predict</span> Aggregator</a>
  <div class="wallet-wrap" id="walletWrap">
    <button class="connect-btn" id="walletBtn" onclick="toggleWalletDropdown()">Connect Wallet</button>
  </div>
</div>

<div class="layout" id="layout">
  <div class="loading" style="grid-column:1/-1;">Loading...</div>
</div>

<script>
const PLATFORMS = {
  polymarket: { name: 'Polymarket', logo: '/public/polymarket.jpg' },
  opinion:    { name: 'Opinion',    logo: '/public/opinion.jpg' },
  limitless:  { name: 'Limitless',  logo: '/public/limitless.svg' },
};

// Orderbook cache: books[team][side] = { pooled, polymarket, limitless, opinion }
let books = {};

async function fetchAllBooks(team) {
  try {
    const eventId = new URLSearchParams(location.search).get('id') || event.id;
    const resp = await fetch(`/api/orderbook/all?event_id=${eventId}&team=${encodeURIComponent(team)}`);
    const data = await resp.json();
    books[team] = {};
    for (const side of ['yes', 'no']) {
      books[team][side] = {
        pooled: data[side]?.pooled || { bids: [], asks: [] },
        ...(data[side]?.platforms || {}),
      };
    }
  } catch (e) {
    books[team] = {};
  }
  return books[team];
}

function getBook(team, side, tab) {
  return books[team]?.[side]?.[tab] || null;
}


let selectedOutcome = 0;
let selectedSide = 'yes';
let selectedTab = 'pooled'; // which platform tab is active
let panelTab = 'buy'; // 'buy' or 'sell'
let event = null;
let userPositions = null;
let selectedPosition = null;
let sellAmount = null;

// Per-team platform availability: { "Spain": ["polymarket","limitless","opinion"], ... }
let teamPlatforms = {};

async function init() {
  const id = new URLSearchParams(location.search).get('id');
  const [evResp, plResp] = await Promise.all([
    fetch('/static/events.json'),
    fetch(`/api/event-platforms?event_id=${id}`),
  ]);
  const events = await evResp.json();
  event = events.find(e => e.id === id) || events[0];
  teamPlatforms = await plResp.json();

  document.title = event.title;
  render();
  loadBooks(event.outcomes[0].name);
}

function platformIcons(platforms) {
  return platforms.map(p => {
    const pl = PLATFORMS[p];
    return `<div class="platform-icon" title="${pl.name}"><img src="${pl.logo}" alt="${pl.name}"></div>`;
  }).join('');
}

// Get live best_ask for yes/no from current tab's book
function livePrice(team, side) {
  const book = getBook(team, side, selectedTab);
  if (!book || !book.best_ask) return null;
  return book.best_ask;
}

function render() {
  const o = event.outcomes[selectedOutcome];
  // Fallback tab if selected platform not available for this outcome
  const available = teamPlatforms[o.name] || [];
  if (selectedTab !== 'pooled' && !available.includes(selectedTab)) {
    selectedTab = 'pooled';
  }

  document.getElementById('layout').innerHTML = `
    <div class="left">
      <!-- Event Header -->
      <div class="event-header">
        <div class="event-top">
          <div class="event-icon">${event.icon}</div>
          <div class="event-title">${event.title}</div>
        </div>
        <div class="event-meta">
          <div class="platform-icons">${platformIcons(event.platforms)}</div>
          <span class="event-meta-item">${event.date}</span>
          <span class="event-meta-item">${event.volume}</span>
          <span class="event-meta-item">${event.txs}</span>
        </div>
      </div>

      <!-- Outcomes Table -->
      <div class="outcomes-section">
        <table class="outcomes-table">
          <thead>
            <tr>
              <th>Outcome</th>
              <th>% Chance</th>
              <th>Buy Yes</th>
              <th>Buy No</th>
            </tr>
          </thead>
          <tbody>
            ${event.outcomes.map((oc, i) => {
              const isSelected = i === selectedOutcome;
              const fb = getBook(oc.name, selectedSide, selectedTab);
              return `
              <tr class="${isSelected ? 'outcome-active' : ''}" style="cursor:pointer" onclick="selectOutcome(${i},'${selectedSide}')">
                <td>
                  <div class="outcome-cell">
                    <span>${oc.name}</span>
                    <div class="platform-icons">${platformIcons(teamPlatforms[oc.name] || [])}</div>
                  </div>
                </td>
                <td class="pct-cell">${(livePrice(oc.name, 'yes') || oc.yesPrice).toFixed(1)}%</td>
                <td style="text-align:center">
                  <button class="buy-btn buy-yes" onclick="event.stopPropagation();selectOutcome(${i},'yes')">Buy Yes<br>${(livePrice(oc.name, 'yes') || oc.yesPrice).toFixed(1)}&#162;</button>
                </td>
                <td style="text-align:center">
                  <button class="buy-btn buy-no" onclick="event.stopPropagation();selectOutcome(${i},'no')">Buy No<br>${(livePrice(oc.name, 'no') || oc.noPrice).toFixed(1)}&#162;</button>
                </td>
              </tr>
              ${isSelected ? `
              <tr><td colspan="4" style="padding:0; border-top:none;">
                <div class="book-inline">
                  <div class="tabs">
                    <button class="tab ${selectedSide==='yes'?'active':''}" onclick="switchSideTab('yes')">Trade Yes</button>
                    <button class="tab ${selectedSide==='no'?'active':''}" onclick="switchSideTab('no')">Trade No</button>
                    <div class="tabs-right">
                      <button class="tab ${selectedTab==='pooled'?'active':''}" onclick="switchPlatform('pooled')">Pooled</button>
                      ${(teamPlatforms[oc.name] || []).map(p => `<button class="tab ${selectedTab===p?'active':''}" onclick="switchPlatform('${p}')">${PLATFORMS[p].name}</button>`).join('')}
                    </div>
                  </div>
                  ${!fb ? '<div style="text-align:center;padding:20px;color:#999;">Loading orderbook...</div>' :
                  fb.asks.length === 0 && fb.bids.length === 0 ? '<div style="text-align:center;padding:20px;color:#999;">No orders</div>' : `
                  <table class="book-table">
                    <thead><tr><th>Price</th><th>Size</th><th>Total</th></tr></thead>
                    <tbody>
                      ${fb.asks.slice(0,5).reverse().map(a => `
                        <tr><td class="price-ask">${a.price_cents}&#162;</td><td>${a.size.toLocaleString()}</td><td>$${a.cumsum.toLocaleString()}</td></tr>
                      `).join('')}
                    </tbody>
                  </table>
                  <div class="book-divider">Best Ask ${fb.best_ask}&#162; / Best Bid ${fb.best_bid}&#162;</div>
                  <table class="book-table">
                    <tbody>
                      ${fb.bids.slice(0,5).map(b => `
                        <tr><td class="price-bid">${b.price_cents}&#162;</td><td>${b.size.toLocaleString()}</td><td>$${b.cumsum.toLocaleString()}</td></tr>
                      `).join('')}
                    </tbody>
                  </table>`}
                </div>
              </td></tr>` : ''}`;
            }).join('')}
          </tbody>
        </table>
      </div>
    </div>

    <!-- Right panel -->
    <div class="buy-panel">
      <div class="panel-header">
        <div class="panel-icon">${event.icon}</div>
        ${o.name}
      </div>

      <div class="panel-tabs">
        <button class="panel-tab ${panelTab === 'buy' ? 'active' : ''}" onclick="switchPanel('buy')">Buy</button>
        <button class="panel-tab ${panelTab === 'sell' ? 'active' : ''}" onclick="switchPanel('sell')">Sell</button>
      </div>

      ${panelTab === 'buy' ? `
      <div class="field-label">Market</div>
      <div class="market-prices">
        <div class="market-price yes ${selectedSide === 'yes' ? 'active' : ''}" onclick="selectSide('yes')">
          <div class="label">Yes</div>
          <div class="val">${(livePrice(o.name, 'yes') || o.yesPrice).toFixed(1)}&#162;</div>
        </div>
        <div class="market-price no ${selectedSide === 'no' ? 'active' : ''}" onclick="selectSide('no')">
          <div class="label">No</div>
          <div class="val">${(livePrice(o.name, 'no') || o.noPrice).toFixed(1)}&#162;</div>
        </div>
      </div>

      <div class="field-label">Amount</div>
      <input type="number" class="amount-input" id="amount" placeholder="0" oninput="onAmountInput(this)" />
      <div class="balance-line">Balance: <b>1.99 USDC</b></div>

      <div class="quick-btns">
        <button class="quick-btn" onclick="setAmount(10)">10</button>
        <button class="quick-btn" onclick="setAmount(50)">50</button>
        <button class="quick-btn" onclick="setAmount(100)">100</button>
        <button class="quick-btn" onclick="setAmount(999)">Max</button>
      </div>

      <div class="field-label">Route</div>
      <div class="route-block">
        ${routeResult && !routeResult.error ? `
        <div class="route-detail">
          ${Object.keys(routeResult.per_platform).map(p => {
            const pp = routeResult.per_platform[p];
            const pl = PLATFORMS[p] || {name:p, logo:''};
            return `<div class="route-row">
              <span><span class="platform-dot"><img src="${pl.logo}" alt="${pl.name}"></span>${pl.name}</span>
              <span class="val">$${pp.spent.toFixed(2)} &middot; ${pp.avg_price_cents.toFixed(1)}&#162;</span>
            </div>`;
          }).join('')}
          <div class="route-row" style="border-top:1px solid #f0f0f0;padding-top:8px;margin-top:4px;font-weight:600;color:#111;">
            <span>Avg. Price</span>
            <span class="val">${routeResult.avg_price_cents.toFixed(1)}&#162;</span>
          </div>
          <div class="route-row" style="font-weight:600;color:#111;">
            <span>Total</span>
            <span class="val">$${routeResult.total_spent.toFixed(2)} &middot; ${routeResult.total_qty.toFixed(0)} shares</span>
          </div>
          ${routeResult.unfilled > 0 ? `<div class="route-row" style="color:#dc2626;"><span>Unfilled</span><span class="val">$${routeResult.unfilled.toFixed(2)}</span></div>` : ''}
        </div>` : `
        <div class="route-empty">&mdash;</div>`}
      </div>

      <div class="to-win">
        <span class="label">To win</span>
        <span class="val">${routeResult ? '$' + routeResult.total_qty.toFixed(2) : '$0.00'}</span>
      </div>

      <button class="submit-btn" id="buyBtn" onclick="submitOrder()">Buy</button>

      ` : `
      <!-- SELL PANEL -->
      ${!walletAddress ? '<div style="text-align:center;padding:20px;color:#999;">Connect wallet to sell</div>' :
        !userPositions ? '<div style="text-align:center;padding:20px;color:#999;">Loading positions…</div>' :
        userPositions.length === 0 ? '<div style="text-align:center;padding:20px;color:#999;">No positions for this outcome</div>' : `

      <div class="field-label">Your Position</div>
      <select class="amount-input" style="font-size:14px;padding:12px 14px;" onchange="selectPosition(parseInt(this.value))">
        ${userPositions.map((pos, i) => {
          const pl = PLATFORMS[pos.platform] || {name: pos.platform};
          return `<option value="${i}" ${selectedPosition === i ? 'selected' : ''}>${pl.name} · ${pos.side.toUpperCase()} @ ${(pos.buy_price * 100).toFixed(1)}¢ · ${pos.shares.toFixed(2)} shares</option>`;
        }).join('')}
      </select>

      ${selectedPosition !== null && userPositions[selectedPosition] ? (() => {
        const pos = userPositions[selectedPosition];
        const bestBid = liveBid(o.name, pos.side, pos.platform);
        const sellShares = sellAmount || pos.shares;
        const estReturn = bestBid ? (sellShares * bestBid / 100).toFixed(2) : '—';
        return `
      <div class="field-label" style="margin-top:16px;">Shares to sell</div>
      <input type="number" class="amount-input" id="sellAmount" placeholder="${pos.shares.toFixed(2)}" value="${sellAmount || ''}" oninput="onSellAmountInput(this)" />
      <div class="balance-line">Available: <b>${pos.shares.toFixed(2)} shares</b></div>

      <div class="quick-btns">
        <button class="quick-btn" onclick="setSellAmount(${Math.floor(pos.shares * 0.25 * 100) / 100})">25%</button>
        <button class="quick-btn" onclick="setSellAmount(${Math.floor(pos.shares * 0.5 * 100) / 100})">50%</button>
        <button class="quick-btn" onclick="setSellAmount(${Math.floor(pos.shares * 100) / 100})">Max</button>
      </div>

      <div class="route-block">
        <div class="route-detail">
          <div class="route-row"><span>Best Bid</span><span class="val">${bestBid ? bestBid.toFixed(1) + '¢' : '—'}</span></div>
          <div class="route-row" style="font-weight:600;color:#111;"><span>Est. Return</span><span class="val">$${estReturn}</span></div>
        </div>
      </div>

      <button class="submit-btn" style="background:#dc2626;" onclick="submitSellOrder()">Sell</button>
      `;
      })() : '<div style="text-align:center;padding:16px;color:#999;font-size:13px;">Select a position above</div>'}
      `}
      `}
    </div>
  `;
}

async function loadBooks(team) {
  await fetchAllBooks(team);
  renderKeepScroll();
}

function selectOutcome(i, side) {
  selectedOutcome = i;
  selectedSide = side;
  routeResult = null;
  selectedPosition = null;
  sellAmount = null;
  if (panelTab === 'sell' && walletAddress) loadPositions();
  const scrollY = window.scrollY;
  render();
  window.scrollTo(0, scrollY);
  // Scroll selected row into view if needed
  const activeRow = document.querySelector('.outcome-active');
  if (activeRow) activeRow.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  const team = event.outcomes[i].name;
  if (!books[team]) loadBooks(team);
}

function selectSide(side) {
  selectedSide = side;
  routeResult = null;
  renderKeepScroll();
}

function switchSideTab(side) {
  selectedSide = side;
  renderKeepScroll();
}

function switchPlatform(platform) {
  selectedTab = platform;
  renderKeepScroll();
}

function renderKeepScroll() {
  const y = window.scrollY;
  const amountEl = document.getElementById('amount');
  const amountVal = amountEl ? amountEl.value : '';
  render();
  const newAmountEl = document.getElementById('amount');
  if (newAmountEl) newAmountEl.value = amountVal;
  window.scrollTo(0, y);
}

let routeResult = null;
let routeTimer = null;

function setAmount(v) {
  document.getElementById('amount').value = v;
  scheduleRoute(v);
}

function onAmountInput(el) {
  scheduleRoute(parseFloat(el.value) || 0);
}

function scheduleRoute(amount) {
  clearTimeout(routeTimer);
  if (!amount || amount <= 0) {
    routeResult = null;
    updateBreakdown();
    return;
  }
  routeTimer = setTimeout(() => fetchRoute(amount), 500);
}

async function fetchRoute(amount) {
  const o = event.outcomes[selectedOutcome];
  const side = selectedSide;
  const eventId = new URLSearchParams(location.search).get('id') || event.id;
  const direction = 'buy';
  try {
    const resp = await fetch(`/api/route?event_id=${eventId}&team=${encodeURIComponent(o.name)}&side=${side}&budget=${amount}&direction=${direction}`);
    routeResult = await resp.json();
  } catch (e) {
    routeResult = null;
  }
  updateBreakdown();
}

function updateBreakdown() {
  renderKeepScroll();
}

// --- Sell panel helpers ---
function liveBid(team, side, platform) {
  // Use the position's platform orderbook, not the selected tab
  const book = getBook(team, side, platform || 'pooled');
  if (!book || !book.best_bid) return null;
  return book.best_bid;
}

function switchPanel(tab) {
  panelTab = tab;
  if (tab === 'sell' && walletAddress) {
    loadPositions();
  }
  selectedPosition = null;
  sellAmount = null;
  renderKeepScroll();
}

async function loadPositions() {
  if (!walletAddress) return;
  const o = event.outcomes[selectedOutcome];
  const eventId = new URLSearchParams(location.search).get('id') || event.id;
  try {
    const resp = await fetch(`/api/positions?wallet=${walletAddress}&event_id=${eventId}&team=${encodeURIComponent(o.name)}`);
    userPositions = await resp.json();
  } catch (e) {
    userPositions = [];
  }
  if (userPositions.length > 0) selectedPosition = 0;
  renderKeepScroll();
}

function selectPosition(i) {
  selectedPosition = i;
  sellAmount = null;
  renderKeepScroll();
}

function setSellAmount(v) {
  sellAmount = v;
  const el = document.getElementById('sellAmount');
  if (el) el.value = v;
  renderKeepScroll();
}

function onSellAmountInput(el) {
  sellAmount = parseFloat(el.value) || null;
}

const POLYGON_CHAIN_ID = '0x89'; // 137
const CTF_ADDRESS = '0x4D97DCd97eC945f40cF65F87097ACe5EA0476045';

async function submitSellOrder() {
  if (!walletAddress) { alert('Connect wallet first'); return; }
  if (selectedPosition === null || !userPositions[selectedPosition]) { alert('Select a position'); return; }

  const pos = userPositions[selectedPosition];
  const sharesToSell = sellAmount || pos.shares;
  if (sharesToSell <= 0) { alert('Enter shares amount'); return; }

  openTxModal('sell');
  setTxStep('approving_sell');

  try {
    // Switch to Polygon
    const chainId = await window.ethereum.request({ method: 'eth_chainId' });
    if (chainId !== POLYGON_CHAIN_ID) {
      try {
        await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: POLYGON_CHAIN_ID }] });
      } catch (switchErr) {
        if (switchErr.code === 4902) {
          await window.ethereum.request({ method: 'wallet_addEthereumChain', params: [{
            chainId: POLYGON_CHAIN_ID, chainName: 'Polygon', nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
            rpcUrls: ['https://polygon-rpc.com'], blockExplorerUrls: ['https://polygonscan.com'],
          }] });
        } else { throw switchErr; }
      }
    }

    // Fetch relayer address from config
    const cfg = await fetch('/api/config').then(r => r.json());
    const relayerAddr = cfg.relayer_address;

    // Check if relayer is approved on CTF
    const isApprovedData = '0xe985e9c5' +
      walletAddress.slice(2).toLowerCase().padStart(64, '0') +
      relayerAddr.slice(2).toLowerCase().padStart(64, '0');
    const approvedHex = await window.ethereum.request({
      method: 'eth_call',
      params: [{ to: CTF_ADDRESS, data: isApprovedData }, 'latest'],
    });
    const isApproved = BigInt(approvedHex) > 0n;

    if (!isApproved) {
      // setApprovalForAll(relayer, true)
      const approveData = '0xa22cb465' +
        relayerAddr.slice(2).toLowerCase().padStart(64, '0') +
        '0000000000000000000000000000000000000000000000000000000000000001';
      const approveTx = await window.ethereum.request({
        method: 'eth_sendTransaction',
        params: [{ from: walletAddress, to: CTF_ADDRESS, data: approveData }],
      });
      setTxMsg('Approving relayer on Polygon…');
      let receipt = null;
      while (!receipt) {
        await new Promise(r => setTimeout(r, 2000));
        receipt = await window.ethereum.request({ method: 'eth_getTransactionReceipt', params: [approveTx] });
      }
      if (receipt.status !== '0x1') { setTxFailed('approving_sell', 'Approval failed'); return; }
      setTxScanLink('approving_sell', `https://polygonscan.com/tx/${approveTx}`);
    }

    // Call POST /api/sell
    setTxStep('pulling');
    setTxMsg('Sending sell request…');

    const resp = await fetch('/api/sell', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ order_id: pos.order_id, amount: sharesToSell }),
    });
    const sellOrder = await resp.json();

    if (sellOrder.error) {
      setTxFailed('pulling', sellOrder.error);
      return;
    }

    setTxScanLink('pulling', `https://polygonscan.com/tx/${sellOrder.pull_tx}`);
    setTxStep('selling');
    setTxMsg('Waiting for sell execution…');

    // Poll sell order status
    let done = false;
    while (!done) {
      await new Promise(r => setTimeout(r, 5000));
      const st = await fetch(`/api/order/${sellOrder.id}`).then(r => r.json());

      if (st.status === 'sell_matched') {
        setTxStep('settling_sell');
        setTxMsg('Sell matched, waiting for USDC…');
      } else if (st.status === 'sell_settled') {
        setTxStep('bridging_back');
        setTxMsg('Bridging USDC back to Base…');
      } else if (st.status === 'bridging_back') {
        setTxStep('bridging_back');
        if (st.bridge_back_tx) {
          setTxScanLink('bridging_back', `https://polygonscan.com/tx/${st.bridge_back_tx}`);
        }
        setTxMsg('Bridge in progress…');
      } else if (st.status === 'completed') {
        setTxDone('USDC delivered to your wallet on Base');
        if (st.receiving_tx_hash) {
          setTxScanLink('done', `https://basescan.org/tx/${st.receiving_tx_hash}`);
        }
        done = true;
      } else if (st.status === 'trade_failed') {
        setTxFailed('selling', st.trade_error || 'Sell failed');
        done = true;
      } else if (st.status === 'bridge_failed') {
        setTxFailed('bridging_back', st.bridge_error || 'Bridge back failed');
        done = true;
      }
    }
  } catch (e) {
    setTxFailed('approving_sell', e.message || String(e));
  }
}

// --- Buy flow ---
const USDC_ADDRESS = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';
const BASE_CHAIN_ID = '0x2105'; // 8453

async function submitOrder() {
  if (!walletAddress) { alert('Connect wallet first'); return; }
  if (!routeResult || routeResult.total_spent <= 0) { alert('Enter amount first'); return; }

  const o = event.outcomes[selectedOutcome];
  const budget = routeResult.total_spent;
  const cfg = await fetch('/api/config').then(r => r.json());
  const routerAddr = cfg.router_address;
  if (!routerAddr) { alert('Router not configured'); return; }

  openTxModal('buy');
  setTxStep('approving');

  try {
    // Switch to Base if needed
    const chainId = await window.ethereum.request({ method: 'eth_chainId' });
    if (chainId !== BASE_CHAIN_ID) {
      await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: BASE_CHAIN_ID }] });
    }

    // Check existing allowance before approving
    const allowanceData = '0xdd62ed3e' +
      walletAddress.slice(2).toLowerCase().padStart(64, '0') +
      routerAddr.slice(2).toLowerCase().padStart(64, '0');
    const allowanceHex = await window.ethereum.request({
      method: 'eth_call',
      params: [{ to: USDC_ADDRESS, data: allowanceData }, 'latest'],
    });
    const allowance = BigInt(allowanceHex);
    const needed = BigInt(Math.round(budget * 1e6));

    let approveTx = null;
    if (allowance >= needed) {
      setTxStep('approved');
      setTxMsg('USDC already approved');
    } else {
      const approveData = '0x095ea7b3' +
        routerAddr.slice(2).toLowerCase().padStart(64, '0') +
        needed.toString(16).padStart(64, '0');

      approveTx = await window.ethereum.request({
        method: 'eth_sendTransaction',
        params: [{ from: walletAddress, to: USDC_ADDRESS, data: approveData }],
      });

      setTxMsg('Waiting for confirmation…');

      let receipt = null;
      while (!receipt) {
        await new Promise(r => setTimeout(r, 2000));
        receipt = await window.ethereum.request({
          method: 'eth_getTransactionReceipt',
          params: [approveTx],
        });
      }

      if (receipt.status !== '0x1') { setTxFailed('approving', 'Approve transaction reverted'); return; }

      setTxStep('approved');
      setTxScanLink('approved', `https://basescan.org/tx/${approveTx}`);
    }

    // Relay via backend
    setTxStep('relaying');
    const eventId = new URLSearchParams(location.search).get('id') || event.id;
    const resp = await fetch('/api/order', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        wallet: walletAddress,
        event_id: eventId,
        team: o.name,
        side: selectedSide,
        budget: budget,
        route: routeResult,
        approve_tx_hash: approveTx,
      }),
    });
    const order = await resp.json();

    if (order.status !== 'sent') {
      setTxFailed('relaying', order.error || 'Relay failed');
      return;
    }

    setTxStep('sent');
    setTxScanLink('sent', `https://basescan.org/tx/${order.tx_hash}`);

    // Poll order status
    setTxStep('bridging');
    setTxMsg('Waiting for bridge confirmation…');

    let settled = false;
    while (!settled) {
      await new Promise(r => setTimeout(r, 5000));
      const st = await fetch(`/api/order/${order.id}`).then(r => r.json());
      if (st.status === 'bridged') {
        if (st.receiving_tx_hash && st.receiving_chain_id) {
          const scan = st.receiving_chain_id === 137 ? 'polygonscan.com' : 'basescan.org';
          setTxScanLink('bridging', `https://${scan}/tx/${st.receiving_tx_hash}`);
        }
        setTxStep('trading');
        setTxMsg('Placing orders on markets…');
      } else if (st.status === 'matched') {
        setTxStep('settling');
        setTxMsg('Waiting for settlement & transferring shares…');
      } else if (st.status === 'filled') {
        setTxDone('Shares delivered to your wallet');
        if (st.transfer_results) {
          const txs = Object.values(st.transfer_results);
          const tx = txs.find(t => t.tx_hash);
          if (tx) {
            setTxScanLink('settling', `https://polygonscan.com/tx/${tx.tx_hash}`);
          }
        }
        settled = true;
      } else if (st.status === 'failed') {
        setTxFailed('bridging', 'Bridge failed');
        settled = true;
      } else if (st.status === 'trade_failed') {
        setTxFailed('trading', st.trade_error || 'Order execution failed');
        settled = true;
      }
    }
  } catch (e) {
    setTxFailed('approving', e.message || String(e));
  }
}

init();

// Wallet connection
let walletAddress = null;

function shortAddr(addr) {
  return addr.slice(0, 6) + '...' + addr.slice(-4);
}

function updateWalletBtn() {
  const btn = document.getElementById('walletBtn');
  if (walletAddress) {
    btn.textContent = shortAddr(walletAddress);
    btn.classList.add('connected');
  } else {
    btn.textContent = 'Connect Wallet';
    btn.classList.remove('connected');
  }
}

async function connectWallet() {
  if (walletAddress) return;
  if (!window.ethereum) {
    alert('No wallet found. Install MetaMask or another wallet.');
    return;
  }
  try {
    // Force account picker to open
    await window.ethereum.request({ method: 'wallet_requestPermissions', params: [{ eth_accounts: {} }] });
    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
    walletAddress = accounts[0];
    localStorage.setItem('walletAddress', walletAddress);
    updateWalletBtn();
  } catch (e) {
    console.error('Wallet connect failed:', e);
  }
}

(function restoreWallet() {
  const saved = localStorage.getItem('walletAddress');
  if (saved) {
    walletAddress = saved;
    updateWalletBtn();
  }
  if (window.ethereum) {
    window.ethereum.on('accountsChanged', (accounts) => {
      walletAddress = accounts[0] || null;
      if (walletAddress) localStorage.setItem('walletAddress', walletAddress);
      else localStorage.removeItem('walletAddress');
      updateWalletBtn();
    });
  }
})();
</script>
<script src="/static/tx-modal.js"></script>
<script src="/static/wallet-dropdown.js"></script>
</body>
</html>
