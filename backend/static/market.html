<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Market Detail</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, sans-serif; background: #f7f8fa; color: #1a1a1a; }

    /* Back link */
    .back {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 16px 32px; font-size: 14px; color: #555; text-decoration: none;
      background: #fff; width: 100%; border-bottom: 1px solid #e5e5e5;
    }
    .back:hover { color: #111; }

    /* Layout */
    .layout {
      max-width: 1000px; margin: 24px auto; padding: 0 20px;
      display: grid; grid-template-columns: 1fr 320px; gap: 24px; align-items: start;
    }
    @media (max-width: 760px) { .layout { grid-template-columns: 1fr; } }

    /* Event header */
    .event-header {
      background: #fff; border-radius: 16px; padding: 24px;
      border: 1px solid #e8e8e8; margin-bottom: 20px;
    }
    .event-top { display: flex; align-items: center; gap: 16px; margin-bottom: 12px; }
    .event-icon {
      width: 56px; height: 56px; border-radius: 14px; background: #f0f0f5;
      display: flex; align-items: center; justify-content: center; font-size: 28px;
    }
    .event-title { font-size: 22px; font-weight: 700; }
    .event-meta {
      display: flex; align-items: center; gap: 16px; flex-wrap: wrap;
    }
    .event-meta-item { font-size: 13px; color: #888; display: flex; align-items: center; gap: 4px; }
    .platform-icons { display: flex; gap: 4px; }
    .platform-icon {
      width: 22px; height: 22px; border-radius: 50%; overflow: hidden; flex-shrink: 0;
    }
    .platform-icon img { width: 100%; height: 100%; object-fit: cover; }

    /* Outcomes table */
    .outcomes-section {
      background: #fff; border-radius: 16px; padding: 24px;
      border: 1px solid #e8e8e8;
    }
    .outcomes-table { width: 100%; border-collapse: collapse; }
    .outcomes-table th {
      text-align: left; font-size: 11px; color: #999; text-transform: uppercase;
      letter-spacing: 0.5px; padding: 0 12px 12px; font-weight: 600;
    }
    .outcomes-table th:nth-child(3),
    .outcomes-table th:nth-child(4) { text-align: center; }
    .outcomes-table td { padding: 14px 12px; border-top: 1px solid #f0f0f0; }
    .outcome-cell { display: flex; align-items: center; gap: 10px; }
    .outcome-cell .platform-icons { margin-left: 4px; }
    .pct-cell { font-size: 18px; font-weight: 700; }
    .buy-btn {
      padding: 10px 18px; border-radius: 8px; font-size: 13px; font-weight: 600;
      border: none; cursor: pointer; min-width: 44px; min-height: 44px;
      transition: background .15s;
    }
    .buy-yes { background: #dcfce7; color: #16a34a; }
    .buy-yes:hover { background: #bbf7d0; }
    .buy-no { background: #fee2e2; color: #dc2626; }
    .buy-no:hover { background: #fecaca; }

    /* Order book tabs */
    .tabs {
      display: flex; gap: 0; margin-bottom: 20px; border-bottom: 1px solid #e8e8e8;
    }
    .tabs-right { margin-left: auto; display: flex; }
    .tab {
      padding: 10px 14px; font-size: 12px; color: #888; cursor: pointer;
      border-bottom: 2px solid transparent; font-weight: 500;
      background: none; border-top: none; border-left: none; border-right: none;
    }
    .tab.active { color: #111; border-bottom-color: #6366f1; font-weight: 600; }
    .tab:hover { color: #111; }

    .outcome-active td { background: #f7f8fa; }

    .book-inline {
      padding: 16px 4px; border-top: 1px solid #f0f0f0;
    }

    .book-section {
      background: #fff; border-radius: 16px; padding: 24px;
      border: 1px solid #e8e8e8; margin-top: 20px;
    }
    .book-table { width: 100%; border-collapse: collapse; table-layout: fixed; }
    .book-table th {
      text-align: right; font-size: 11px; color: #999; text-transform: uppercase;
      padding: 0 8px 10px; font-weight: 600;
    }
    .book-table th:first-child, .book-table td:first-child { width: 30%; text-align: left; }
    .book-table th:nth-child(2), .book-table td:nth-child(2) { width: 35%; }
    .book-table th:nth-child(3), .book-table td:nth-child(3) { width: 35%; }
    .book-table td { padding: 8px; text-align: right; font-size: 14px; border-top: 1px solid #f7f7f7; }
    .price-ask { color: #dc2626; font-weight: 600; }
    .price-bid { color: #16a34a; font-weight: 600; }
    .book-divider {
      text-align: center; padding: 10px; font-size: 13px; color: #888;
      border-top: 1px solid #f0f0f0; border-bottom: 1px solid #f0f0f0;
    }
    .book-divider span { color: #16a34a; }

    /* Right panel - Buy */
    .buy-panel {
      background: #fff; border-radius: 16px; padding: 24px;
      border: 1px solid #e8e8e8; position: sticky; top: 24px;
    }
    .panel-header {
      display: flex; align-items: center; gap: 10px;
      margin-bottom: 20px; font-size: 16px; font-weight: 700;
    }
    .panel-icon {
      width: 32px; height: 32px; border-radius: 8px; background: #f0f0f5;
      display: flex; align-items: center; justify-content: center; font-size: 16px;
    }

    .panel-tabs { display: flex; margin-bottom: 20px; border-bottom: 1px solid #e8e8e8; }
    .panel-tab {
      flex: 1; text-align: center; padding: 10px; font-size: 14px; font-weight: 500;
      color: #888; cursor: pointer; border-bottom: 2px solid transparent;
      background: none; border-top: none; border-left: none; border-right: none;
    }
    .panel-tab.active { color: #111; border-bottom-color: #6366f1; }

    .market-prices { display: flex; gap: 10px; margin-bottom: 20px; }
    .market-price {
      flex: 1; padding: 14px; border-radius: 12px; text-align: center;
      cursor: pointer; border: 2px solid transparent;
    }
    .market-price.yes { background: #dcfce7; color: #16a34a; }
    .market-price.yes.active { border-color: #16a34a; }
    .market-price.no { background: #fee2e2; color: #dc2626; }
    .market-price.no.active { border-color: #dc2626; }
    .market-price .label { font-size: 12px; font-weight: 600; }
    .market-price .val { font-size: 22px; font-weight: 700; }

    .field-label { font-size: 13px; color: #888; margin-bottom: 6px; }
    .amount-input {
      width: 100%; padding: 14px 16px; border-radius: 10px;
      border: 1px solid #e5e5e5; font-size: 24px; font-weight: 700;
      text-align: right; margin-bottom: 8px; outline: none;
    }
    .amount-input:focus { border-color: #6366f1; }
    .amount-input::-webkit-outer-spin-button,
    .amount-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    .amount-input { -moz-appearance: textfield; }
    .balance-line {
      text-align: right; font-size: 13px; color: #888; margin-bottom: 12px;
    }
    .quick-btns { display: flex; gap: 8px; margin-bottom: 20px; }
    .quick-btn {
      flex: 1; padding: 10px; border-radius: 8px; border: 1px solid #e5e5e5;
      background: #fff; font-size: 13px; font-weight: 600; cursor: pointer;
      min-height: 44px;
    }
    .quick-btn:hover { background: #f7f8fa; }

    .route-block {
      border: 1px solid #e8e8e8; border-radius: 12px; margin-bottom: 16px; overflow: hidden;
    }
    .route-detail { padding: 12px 16px; }
    .route-row {
      display: flex; justify-content: space-between; align-items: center;
      padding: 7px 0; font-size: 13px; color: #555;
    }
    .route-row .val { font-weight: 600; color: #111; }
    .route-row .platform-dot {
      width: 18px; height: 18px; border-radius: 50%; overflow: hidden;
      display: inline-flex; align-items: center; justify-content: center;
      vertical-align: middle; margin-right: 6px;
    }
    .route-row .platform-dot img { width: 100%; height: 100%; object-fit: cover; }
    .route-empty { padding: 14px 16px; text-align: center; font-size: 13px; color: #bbb; }

    .to-win {
      display: flex; justify-content: space-between; align-items: center;
      padding: 12px 0; margin-bottom: 16px; font-size: 14px;
    }
    .to-win .label { color: #888; font-weight: 500; }
    .to-win .val { font-size: 20px; font-weight: 700; color: #16a34a; }

    .submit-btn {
      width: 100%; padding: 16px; border-radius: 12px; border: none;
      background: #16a34a; color: #fff; font-size: 16px; font-weight: 700;
      cursor: pointer; min-height: 52px; transition: background .15s;
    }
    .submit-btn:hover { background: #15803d; }
    .submit-btn:disabled { opacity: .5; cursor: default; }

    .loading { text-align: center; padding: 60px; color: #999; }

    .top-bar {
      background: #fff; border-bottom: 1px solid #e5e5e5;
      padding: 12px 32px; display: flex; align-items: center; justify-content: space-between;
    }
    .top-bar .logo { font-size: 22px; font-weight: 700; letter-spacing: -0.5px; text-decoration: none; color: #1a1a1a; }
    .top-bar .logo span { color: #6366f1; }
    .connect-btn {
      padding: 10px 20px; border-radius: 10px; border: none;
      background: #6366f1; color: #fff; font-size: 14px; font-weight: 600;
      cursor: pointer; transition: background .15s;
    }
    .connect-btn:hover { background: #4f46e5; }
    .connect-btn.connected { background: #16a34a; }
    .connect-btn.connected:hover { background: #15803d; }
  </style>
</head>
<body>

<div class="top-bar">
  <a href="/" class="logo"><span>Predict</span> Aggregator</a>
  <div class="wallet-wrap" id="walletWrap">
    <button class="connect-btn" id="walletBtn" onclick="toggleWalletDropdown()">Connect Wallet</button>
  </div>
</div>

<div class="layout" id="layout">
  <div class="loading" style="grid-column:1/-1;">Loading...</div>
</div>

<script>
const PLATFORMS = {
  polymarket: { name: 'Polymarket', logo: '/public/polymarket.jpg', chain: 137 },
  opinion:    { name: 'Opinion',    logo: '/public/opinion.jpg', chain: 56 },
  limitless:  { name: 'Limitless',  logo: '/public/limitless.svg', chain: 8453 },
};

// CTF (Conditional Tokens) per platform for ERC-1155 approvals
const PLATFORM_CTF = {
  polymarket: '0x4D97DCd97eC945f40cF65F87097ACe5EA0476045',
  limitless:  '0xC9c98965297Bc527861c898329Ee280632B76e18',
  opinion:    '0xAD1a38cEc043e70E83a3eC30443dB285ED10D774',
};

// Chain hex IDs and scanners
const CHAIN_HEX = { 137: '0x89', 56: '0x38', 8453: '0x2105' };
const CHAIN_SCAN = { 137: 'polygonscan.com', 56: 'bscscan.com', 8453: 'basescan.org' };
const CHAIN_NAME = { 137: 'Polygon', 56: 'BSC', 8453: 'Base' };
const PLATFORM_DECIMALS = { polymarket: 6, opinion: 18, limitless: 6 };

// Orderbook cache: books[team][side] = { pooled, polymarket, limitless, opinion }
let books = {};

async function fetchAllBooks(team) {
  try {
    const eventId = new URLSearchParams(location.search).get('id') || event.id;
    const resp = await fetch(`/api/orderbook/all?event_id=${eventId}&team=${encodeURIComponent(team)}`);
    const data = await resp.json();
    books[team] = {};
    for (const side of ['yes', 'no']) {
      books[team][side] = {
        pooled: data[side]?.pooled || { bids: [], asks: [] },
        ...(data[side]?.platforms || {}),
      };
    }
  } catch (e) {
    books[team] = {};
  }
  return books[team];
}

function getBook(team, side, tab) {
  return books[team]?.[side]?.[tab] || null;
}


let selectedOutcome = 0;
let selectedSide = 'yes';
let selectedTab = 'pooled'; // which platform tab is active
let panelTab = 'buy'; // 'buy' or 'sell'
let event = null;
let userPositions = null;
let selectedPosition = null;
let sellAmount = null;
let userBalance = null; // USDC balance in human-readable

// Per-team platform availability: { "Spain": ["polymarket","limitless","opinion"], ... }
let teamPlatforms = {};

async function init() {
  const id = new URLSearchParams(location.search).get('id');
  const [evResp, plResp] = await Promise.all([
    fetch('/static/events.json'),
    fetch(`/api/event-platforms?event_id=${id}`),
  ]);
  const events = await evResp.json();
  event = events.find(e => e.id === id) || events[0];
  teamPlatforms = await plResp.json();

  document.title = event.title;
  render();
  loadBooks(event.outcomes[0].name);
}

function platformIcons(platforms) {
  return platforms.map(p => {
    const pl = PLATFORMS[p];
    return `<div class="platform-icon" title="${pl.name}"><img src="${pl.logo}" alt="${pl.name}"></div>`;
  }).join('');
}

// Get live best_ask for yes/no from current tab's book
function livePrice(team, side) {
  const book = getBook(team, side, selectedTab);
  if (!book || !book.best_ask) return null;
  return book.best_ask;
}

function render() {
  const o = selectedOutcome !== null ? event.outcomes[selectedOutcome] : null;
  // Fallback tab if selected platform not available for this outcome
  const available = o ? (teamPlatforms[o.name] || []) : [];
  if (selectedTab !== 'pooled' && !available.includes(selectedTab)) {
    selectedTab = 'pooled';
  }

  document.getElementById('layout').innerHTML = `
    <div class="left">
      <!-- Event Header -->
      <div class="event-header">
        <div class="event-top">
          <div class="event-icon">${event.icon}</div>
          <div class="event-title">${event.title}</div>
        </div>
        <div class="event-meta">
          <div class="platform-icons">${platformIcons(event.platforms)}</div>
          <span class="event-meta-item">${event.date}</span>
          <span class="event-meta-item">${event.volume}</span>
          <span class="event-meta-item">${event.txs}</span>
        </div>
      </div>

      <!-- Outcomes Table -->
      <div class="outcomes-section">
        <table class="outcomes-table">
          <thead>
            <tr>
              <th>Outcome</th>
              <th>% Chance</th>
              <th>Buy Yes</th>
              <th>Buy No</th>
            </tr>
          </thead>
          <tbody>
            ${event.outcomes.map((oc, i) => {
              const isSelected = i === selectedOutcome;
              const fb = getBook(oc.name, selectedSide, selectedTab);
              return `
              <tr class="${isSelected ? 'outcome-active' : ''}" style="cursor:pointer" onclick="selectOutcome(${i},'${selectedSide}')">
                <td>
                  <div class="outcome-cell">
                    <span>${oc.name}</span>
                    <div class="platform-icons">${platformIcons(teamPlatforms[oc.name] || [])}</div>
                  </div>
                </td>
                <td class="pct-cell">${(livePrice(oc.name, 'yes') || oc.yesPrice).toFixed(1)}%</td>
                <td style="text-align:center">
                  <button class="buy-btn buy-yes" onclick="event.stopPropagation();selectOutcome(${i},'yes')">Buy Yes<br>${(livePrice(oc.name, 'yes') || oc.yesPrice).toFixed(1)}&#162;</button>
                </td>
                <td style="text-align:center">
                  <button class="buy-btn buy-no" onclick="event.stopPropagation();selectOutcome(${i},'no')">Buy No<br>${(livePrice(oc.name, 'no') || oc.noPrice).toFixed(1)}&#162;</button>
                </td>
              </tr>
              ${isSelected ? `
              <tr><td colspan="4" style="padding:0; border-top:none;">
                <div class="book-inline">
                  <div class="tabs">
                    <button class="tab ${selectedSide==='yes'?'active':''}" onclick="switchSideTab('yes')">Trade Yes</button>
                    <button class="tab ${selectedSide==='no'?'active':''}" onclick="switchSideTab('no')">Trade No</button>
                    <div class="tabs-right">
                      <button class="tab ${selectedTab==='pooled'?'active':''}" onclick="switchPlatform('pooled')">Pooled</button>
                      ${(teamPlatforms[oc.name] || []).map(p => `<button class="tab ${selectedTab===p?'active':''}" onclick="switchPlatform('${p}')">${PLATFORMS[p].name}</button>`).join('')}
                    </div>
                  </div>
                  ${!fb ? '<div style="text-align:center;padding:20px;color:#999;">Loading orderbook...</div>' :
                  fb.asks.length === 0 && fb.bids.length === 0 ? '<div style="text-align:center;padding:20px;color:#999;">No orders</div>' : `
                  <table class="book-table">
                    <thead><tr><th>Price</th><th>Size</th><th>Total</th></tr></thead>
                    <tbody>
                      ${fb.asks.slice(0,5).reverse().map(a => `
                        <tr><td class="price-ask">${a.price_cents}&#162;</td><td>${a.size.toLocaleString()}</td><td>$${a.cumsum.toLocaleString()}</td></tr>
                      `).join('')}
                    </tbody>
                  </table>
                  <div class="book-divider">Best Ask ${fb.best_ask}&#162; / Best Bid ${fb.best_bid}&#162;</div>
                  <table class="book-table">
                    <tbody>
                      ${fb.bids.slice(0,5).map(b => `
                        <tr><td class="price-bid">${b.price_cents}&#162;</td><td>${b.size.toLocaleString()}</td><td>$${b.cumsum.toLocaleString()}</td></tr>
                      `).join('')}
                    </tbody>
                  </table>`}
                </div>
              </td></tr>` : ''}`;
            }).join('')}
          </tbody>
        </table>
      </div>
    </div>

    <!-- Right panel -->
    <div class="buy-panel">
    ${!o ? '<div style="text-align:center;padding:40px;color:#999;">Select an outcome</div>' : `
      <div class="panel-header">
        <div class="panel-icon">${event.icon}</div>
        ${o.name}
      </div>

      <div class="panel-tabs">
        <button class="panel-tab ${panelTab === 'buy' ? 'active' : ''}" onclick="switchPanel('buy')">Buy</button>
        <button class="panel-tab ${panelTab === 'sell' ? 'active' : ''}" onclick="switchPanel('sell')">Sell</button>
      </div>

      ${panelTab === 'buy' ? `
      <div class="field-label">Market</div>
      <div class="market-prices">
        <div class="market-price yes ${selectedSide === 'yes' ? 'active' : ''}" onclick="selectSide('yes')">
          <div class="label">Yes</div>
          <div class="val">${(livePrice(o.name, 'yes') || o.yesPrice).toFixed(1)}&#162;</div>
        </div>
        <div class="market-price no ${selectedSide === 'no' ? 'active' : ''}" onclick="selectSide('no')">
          <div class="label">No</div>
          <div class="val">${(livePrice(o.name, 'no') || o.noPrice).toFixed(1)}&#162;</div>
        </div>
      </div>

      <div class="field-label">Amount</div>
      <input type="number" class="amount-input" id="amount" placeholder="0" oninput="onAmountInput(this)" />
      <div class="balance-line">Balance: <b>${userBalance !== null ? userBalance.toFixed(2) : '—'} USDC</b></div>

      <div class="quick-btns">
        <button class="quick-btn" onclick="setAmount(10)">10</button>
        <button class="quick-btn" onclick="setAmount(50)">50</button>
        <button class="quick-btn" onclick="setAmount(100)">100</button>
        <button class="quick-btn" onclick="setAmount(999)">Max</button>
      </div>

      <div class="field-label">Route</div>
      <div class="route-block">
        ${routeResult && !routeResult.error ? `
        <div class="route-detail">
          ${Object.keys(routeResult.per_platform).map(p => {
            const pp = routeResult.per_platform[p];
            const pl = PLATFORMS[p] || {name:p, logo:''};
            return `<div class="route-row">
              <span><span class="platform-dot"><img src="${pl.logo}" alt="${pl.name}"></span>${pl.name}</span>
              <span class="val">$${pp.spent.toFixed(2)} &middot; ${pp.avg_price_cents.toFixed(1)}&#162;</span>
            </div>`;
          }).join('')}
          <div class="route-row" style="border-top:1px solid #f0f0f0;padding-top:8px;margin-top:4px;font-weight:600;color:#111;">
            <span>Avg. Price</span>
            <span class="val">${routeResult.avg_price_cents.toFixed(1)}&#162;</span>
          </div>
          <div class="route-row" style="font-weight:600;color:#111;">
            <span>Total</span>
            <span class="val">$${routeResult.total_spent.toFixed(2)} &middot; ${routeResult.total_qty.toFixed(0)} shares</span>
          </div>
          ${routeResult.unfilled > 0 ? `<div class="route-row" style="color:#dc2626;"><span>Unfilled</span><span class="val">$${routeResult.unfilled.toFixed(2)}</span></div>` : ''}
        </div>` : `
        <div class="route-empty">&mdash;</div>`}
      </div>

      <div class="to-win">
        <span class="label">To win</span>
        <span class="val">${routeResult ? '$' + routeResult.total_qty.toFixed(2) : '$0.00'}</span>
      </div>

      <button class="submit-btn" id="buyBtn" onclick="openChainSelectModal('buy', (c) => submitOrder(c))">Buy</button>

      ${event.id === 'anthropic-acquired-2027' ? `
      <div style="margin-top:16px;padding-top:16px;border-top:1px solid #eee;">
        <div style="display:flex;gap:8px;align-items:center;">
          <input type="number" id="testBatchAmount" value="6" style="width:70px;padding:8px 10px;border:1px solid #ddd;border-radius:8px;font-size:14px;" />
          <button onclick="testBatch()" style="flex:1;padding:8px 16px;background:#7c3aed;color:#fff;border:none;border-radius:8px;font-weight:600;font-size:14px;cursor:pointer;">Test Batch Buy</button>
        </div>
        <div style="font-size:11px;color:#999;margin-top:4px;">Split 50/50: Polymarket + Limitless from BSC</div>
      </div>` : ''}

      ` : `
      <!-- SELL PANEL -->
      <div class="field-label">Market</div>
      <div class="market-prices">
        <div class="market-price yes ${selectedSide === 'yes' ? 'active' : ''}" onclick="selectSide('yes')">
          <div class="label">Yes</div>
          <div class="val">${(livePrice(o.name, 'yes') || o.yesPrice).toFixed(1)}&#162;</div>
        </div>
        <div class="market-price no ${selectedSide === 'no' ? 'active' : ''}" onclick="selectSide('no')">
          <div class="label">No</div>
          <div class="val">${(livePrice(o.name, 'no') || o.noPrice).toFixed(1)}&#162;</div>
        </div>
      </div>

      ${(() => {
        const hasPos = userPositions && userPositions.length > 0;
        const isAll = selectedPosition === -2;
        const pos = hasPos && selectedPosition !== null && !isAll ? userPositions[selectedPosition] : null;
        const bestBid = pos ? liveBid(o.name, pos.side, pos.platform) : null;
        const avail = isAll ? userPositions.reduce((s, p) => s + p.shares, 0) : (pos ? pos.shares : 0);
        const sellVal = isAll ? avail : (sellAmount || avail);
        const estReturn = isAll
          ? userPositions.reduce((s, p) => { const b = liveBid(o.name, p.side, p.platform); return s + (b ? p.shares * b / 100 : 0); }, 0).toFixed(2)
          : (bestBid && sellVal ? (sellVal * bestBid / 100).toFixed(2) : '—');
        const canSell = isAll ? hasPos : !!pos;
        return `
      <div class="field-label">Your Position</div>
      <select class="amount-input" style="font-size:14px;padding:12px 14px;" onchange="selectPosition(parseInt(this.value))">
        ${!hasPos ? '<option value="-1">No positions</option>' :
        (userPositions.length > 1 ? '<option value="-2"'+(isAll?' selected':'')+'>All positions ('+userPositions.length+')</option>' : '') +
        userPositions.map((p, i) => {
          const pl = PLATFORMS[p.platform] || {name: p.platform};
          return '<option value="'+i+'" '+(selectedPosition === i ? 'selected' : '')+'>'+pl.name+' · '+p.side.toUpperCase()+' @ '+(p.buy_price * 100).toFixed(1)+'¢ · '+p.shares.toFixed(2)+' shares</option>';
        }).join('')}
      </select>

      <div class="field-label" style="margin-top:16px;">Amount</div>
      <input type="number" class="amount-input" id="sellAmount" placeholder="${avail ? avail.toFixed(2) : '0'}" value="${isAll ? '' : (sellAmount || '')}" oninput="onSellAmountInput(this)" ${!canSell || isAll ? 'disabled' : ''} />
      <div class="balance-line">Available: <b>${avail ? avail.toFixed(2) : '0'} shares</b>${isAll ? ' across '+userPositions.length+' platforms' : ''}</div>

      <div class="quick-btns">
        <button class="quick-btn" ${!canSell || isAll ? 'disabled' : ''} onclick="setSellAmount(${Math.floor(avail * 0.25 * 100) / 100})">25%</button>
        <button class="quick-btn" ${!canSell || isAll ? 'disabled' : ''} onclick="setSellAmount(${Math.floor(avail * 0.5 * 100) / 100})">50%</button>
        <button class="quick-btn" ${!canSell || isAll ? 'disabled' : ''} onclick="setSellAmount(${Math.floor(avail * 100) / 100})">Max</button>
      </div>

      <div class="route-block">
        <div class="route-detail">
          <div class="route-row"><span>Best Bid</span><span class="val">${isAll ? '—' : (bestBid ? bestBid.toFixed(1) + '¢' : '—')}</span></div>
          <div class="route-row" style="font-weight:600;color:#111;"><span>Est. Return</span><span class="val">$${estReturn}</span></div>
        </div>
      </div>

      <button class="submit-btn" style="background:#dc2626;" onclick="openChainSelectModal('sell', (c) => selectedPosition === -2 ? submitBatchSell(c) : submitSellOrder(c))" ${!canSell ? 'disabled' : ''}>Sell</button>
      `;
      })()}
      `}
    `}
    </div>
  `;
}

async function loadBooks(team) {
  await fetchAllBooks(team);
  renderKeepScroll();
}

function selectOutcome(i, side) {
  if (selectedOutcome === i && selectedSide === side) {
    selectedOutcome = null;
    renderKeepScroll();
    return;
  }
  selectedOutcome = i;
  selectedSide = side;
  routeResult = null;
  selectedPosition = null;
  sellAmount = null;
  if (panelTab === 'sell' && walletAddress) loadPositions();
  const scrollY = window.scrollY;
  render();
  window.scrollTo(0, scrollY);
  // Scroll selected row into view if needed
  const activeRow = document.querySelector('.outcome-active');
  if (activeRow) activeRow.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  const team = event.outcomes[i].name;
  if (!books[team]) loadBooks(team);
}

function selectSide(side) {
  selectedSide = side;
  routeResult = null;
  if (panelTab === 'sell' && walletAddress) {
    selectedPosition = null;
    sellAmount = null;
    loadPositions();
  }
  renderKeepScroll();
}

function switchSideTab(side) {
  selectedSide = side;
  renderKeepScroll();
}

function switchPlatform(platform) {
  selectedTab = platform;
  renderKeepScroll();
}

function renderKeepScroll() {
  const y = window.scrollY;
  const amountEl = document.getElementById('amount');
  const amountVal = amountEl ? amountEl.value : '';
  render();
  const newAmountEl = document.getElementById('amount');
  if (newAmountEl) newAmountEl.value = amountVal;
  window.scrollTo(0, y);
}

let routeResult = null;
let routeTimer = null;

function setAmount(v) {
  document.getElementById('amount').value = v;
  scheduleRoute(v);
}

function onAmountInput(el) {
  scheduleRoute(parseFloat(el.value) || 0);
}

function scheduleRoute(amount) {
  clearTimeout(routeTimer);
  if (!amount || amount <= 0) {
    routeResult = null;
    updateBreakdown();
    return;
  }
  routeTimer = setTimeout(() => fetchRoute(amount), 500);
}

async function fetchRoute(amount) {
  const o = event.outcomes[selectedOutcome];
  const side = selectedSide;
  const eventId = new URLSearchParams(location.search).get('id') || event.id;
  const direction = 'buy';
  try {
    const resp = await fetch(`/api/route?event_id=${eventId}&team=${encodeURIComponent(o.name)}&side=${side}&budget=${amount}&direction=${direction}`);
    routeResult = await resp.json();
  } catch (e) {
    routeResult = null;
  }
  updateBreakdown();
}

function updateBreakdown() {
  renderKeepScroll();
}

// --- Sell panel helpers ---
function liveBid(team, side, platform) {
  // Use the position's platform orderbook, not the selected tab
  const book = getBook(team, side, platform || 'pooled');
  if (!book || !book.best_bid) return null;
  return book.best_bid;
}

function switchPanel(tab) {
  panelTab = tab;
  if (tab === 'sell' && walletAddress) {
    loadPositions();
  }
  selectedPosition = null;
  sellAmount = null;
  renderKeepScroll();
}

async function loadPositions() {
  if (!walletAddress) return;
  const o = event.outcomes[selectedOutcome];
  const eventId = new URLSearchParams(location.search).get('id') || event.id;
  try {
    const resp = await fetch(`/api/positions?wallet=${walletAddress}&event_id=${eventId}&team=${encodeURIComponent(o.name)}&side=${selectedSide}`);
    userPositions = await resp.json();
  } catch (e) {
    userPositions = [];
  }
  if (userPositions.length > 0) selectedPosition = 0;
  renderKeepScroll();
}

function selectPosition(i) {
  selectedPosition = i;
  sellAmount = null;
  renderKeepScroll();
}

function setSellAmount(v) {
  sellAmount = v;
  const el = document.getElementById('sellAmount');
  if (el) el.value = v;
  renderKeepScroll();
}

function onSellAmountInput(el) {
  sellAmount = parseFloat(el.value) || null;
}

async function submitSellOrder(toChainId) {
  if (!walletAddress) { alert('Connect wallet first'); return; }
  if (selectedPosition === null || !userPositions[selectedPosition]) { alert('Select a position'); return; }

  const pos = userPositions[selectedPosition];
  const sharesToSell = sellAmount || pos.shares;
  if (sharesToSell <= 0) { alert('Enter shares amount'); return; }

  const pl = PLATFORMS[pos.platform] || {};
  const posChain = pl.chain || 137;
  const posChainHex = CHAIN_HEX[posChain] || '0x89';
  const posScan = CHAIN_SCAN[posChain] || 'polygonscan.com';
  const ctfAddr = PLATFORM_CTF[pos.platform] || PLATFORM_CTF.polymarket;
  const toScan = CHAIN_SCAN[toChainId] || 'basescan.org';

  // No bridge if proceeds go to the same chain as the platform
  const sameChain = toChainId === posChain;
  openTxModal('sell', sameChain, CHAIN_NAME[toChainId] || 'Base');
  setTxStep('approving_sell');

  try {
    const cfg = await fetch('/api/config').then(r => r.json());
    const isOpinion = pos.platform === 'opinion';

    // Opinion: shares stay on smart wallet, no approval/pull needed
    if (!isOpinion) {
      // Switch to platform chain (where shares live)
      const chainId = await window.ethereum.request({ method: 'eth_chainId' });
      if (chainId !== posChainHex) {
        try {
          await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: posChainHex }] });
        } catch (switchErr) {
          if (switchErr.code === 4902) {
            throw new Error(`Please add chain ${posChain} to your wallet`);
          } else { throw switchErr; }
        }
      }

      // Always approve Router on platform chain
      const chainRouters = cfg.chain_routers || {};
      const operatorAddr = chainRouters[String(posChain)] || cfg.router_address;

      // Check if operator is approved on CTF
      const isApprovedData = '0xe985e9c5' +
        walletAddress.slice(2).toLowerCase().padStart(64, '0') +
        operatorAddr.slice(2).toLowerCase().padStart(64, '0');
      const approvedHex = await window.ethereum.request({
        method: 'eth_call',
        params: [{ to: ctfAddr, data: isApprovedData }, 'latest'],
      });
      const isApproved = approvedHex && approvedHex.length > 2 && BigInt(approvedHex) > 0n;

      if (!isApproved) {
        const approveData = '0xa22cb465' +
          operatorAddr.slice(2).toLowerCase().padStart(64, '0') +
          '0000000000000000000000000000000000000000000000000000000000000001';
        const approveTx = await window.ethereum.request({
          method: 'eth_sendTransaction',
          params: [{ from: walletAddress, to: ctfAddr, data: approveData }],
        });
        setTxMsg(posChain === 8453 ? 'Approving Router…' : 'Approving Relayer…');
        let receipt = null;
        while (!receipt) {
          await new Promise(r => setTimeout(r, 2000));
          receipt = await window.ethereum.request({ method: 'eth_getTransactionReceipt', params: [approveTx] });
        }
        if (receipt.status !== '0x1') { setTxFailed('approving_sell', 'Approval failed'); return; }
        setTxScanLink('approving_sell', `https://${posScan}/tx/${approveTx}`);
      }
    }

    // Call POST /api/sell with to_chain
    setTxStep('pulling');
    setTxMsg('Sending sell request…');

    const resp = await fetch('/api/sell', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ order_id: pos.order_id, amount: sharesToSell, to_chain: toChainId }),
    });
    const sellOrder = await resp.json();

    if (sellOrder.error) {
      setTxFailed('pulling', sellOrder.error);
      return;
    }

    setTxScanLink('pulling', `https://${posScan}/tx/${sellOrder.pull_tx}`);
    setTxStep('selling');
    setTxMsg('Waiting for sell execution…');

    // Poll sell order status
    let done = false;
    while (!done) {
      await new Promise(r => setTimeout(r, 5000));
      const st = await fetch(`/api/order/${sellOrder.id}`).then(r => r.json());

      if (st.status === 'sell_matched') {
        setTxStep('settling_sell');
        setTxMsg('Sell matched, waiting for USDC…');
      } else if (st.status === 'sell_settled') {
        if (sameChain) {
          setTxStep('settling_sell');
          setTxMsg('Transferring USDC…');
        } else {
          setTxStep('bridging_back');
          setTxMsg(`Bridging USDC to ${CHAINS.find(c=>c.id===toChainId)?.name||'target chain'}…`);
        }
      } else if (st.status === 'bridging_back') {
        setTxStep('bridging_back');
        if (st.bridge_back_tx) {
          setTxScanLink('bridging_back', `https://${posScan}/tx/${st.bridge_back_tx}`);
        }
        setTxMsg('Bridge in progress…');
      } else if (st.status === 'completed') {
        const dec = PLATFORM_DECIMALS[pos.platform] || 6;
        const sharesSold = (st.shares_amount || 0) / (10 ** dec);
        const proceeds = st.settle_results?.proceeds ? st.settle_results.proceeds / (10 ** dec) : 0;
        const msg = proceeds > 0
          ? `Sold ${sharesSold.toFixed(2)} shares → $${proceeds.toFixed(2)} USDC`
          : 'USDC delivered to your wallet';
        setTxDone(msg);
        const completedScan = st.receiving_tx_hash ? `https://${toScan}/tx/${st.receiving_tx_hash}` :
                              st.bridge_back_tx ? `https://${posScan}/tx/${st.bridge_back_tx}` : null;
        if (completedScan) setTxScanLink('done', completedScan);
        done = true;
        loadPositions();
        fetchBalance();
      } else if (st.status === 'trade_failed') {
        setTxFailed('selling', st.trade_error || 'Sell failed');
        done = true;
      } else if (st.status === 'bridge_failed') {
        setTxFailed('bridging_back', st.bridge_error || 'Bridge back failed');
        done = true;
      }
    }
  } catch (e) {
    setTxFailed('approving_sell', e.message || String(e));
  }
}

// --- Batch sell flow ---
async function submitBatchSell(toChainId) {
  if (!walletAddress) { alert('Connect wallet first'); return; }
  if (!userPositions || userPositions.length === 0) { alert('No positions'); return; }

  const positions = [...userPositions];
  const toChainName = CHAIN_NAME[toChainId] || 'Base';

  // Open batch modal
  openTxModal('batch_sell', false, toChainName);
  setTxStep('batch_approving');

  try {
    const cfg = await fetch('/api/config').then(r => r.json());
    const chainRouters = cfg.chain_routers || {};

    // Group positions by chain for approval batching
    const byChain = {};
    for (const p of positions) {
      const pl = PLATFORMS[p.platform] || {};
      const chain = pl.chain || 137;
      if (!byChain[chain]) byChain[chain] = [];
      byChain[chain].push(p);
    }

    // Phase 1: Approve Router on each chain's CTF
    for (const [chainIdStr, chainPositions] of Object.entries(byChain)) {
      const chainId = parseInt(chainIdStr);
      const chainHex = CHAIN_HEX[chainId] || '0x89';
      const chainScan = CHAIN_SCAN[chainId] || 'polygonscan.com';

      // Skip approval for opinion (shares on smart wallet)
      const nonOpinion = chainPositions.filter(p => p.platform !== 'opinion');
      if (nonOpinion.length === 0) continue;

      // Switch chain
      setTxMsg(`Switching to ${CHAIN_NAME[chainId] || chainId}...`);
      const curChain = await window.ethereum.request({ method: 'eth_chainId' });
      if (curChain !== chainHex) {
        try {
          await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: chainHex }] });
        } catch (switchErr) {
          if (switchErr.code === 4902) throw new Error(`Please add chain ${chainId} to your wallet`);
          throw switchErr;
        }
      }

      // Approve each unique CTF on this chain
      const approvedCtfs = new Set();
      for (const p of nonOpinion) {
        const ctfAddr = PLATFORM_CTF[p.platform] || PLATFORM_CTF.polymarket;
        if (approvedCtfs.has(ctfAddr)) continue;
        approvedCtfs.add(ctfAddr);

        const operatorAddr = chainRouters[String(chainId)] || cfg.router_address;
        const isApprovedData = '0xe985e9c5' +
          walletAddress.slice(2).toLowerCase().padStart(64, '0') +
          operatorAddr.slice(2).toLowerCase().padStart(64, '0');
        const approvedHex = await window.ethereum.request({
          method: 'eth_call',
          params: [{ to: ctfAddr, data: isApprovedData }, 'latest'],
        });
        const isApproved = approvedHex && approvedHex.length > 2 && BigInt(approvedHex) > 0n;

        if (!isApproved) {
          setTxMsg(`Approving on ${CHAIN_NAME[chainId]}...`);
          const approveData = '0xa22cb465' +
            operatorAddr.slice(2).toLowerCase().padStart(64, '0') +
            '0000000000000000000000000000000000000000000000000000000000000001';
          const approveTx = await window.ethereum.request({
            method: 'eth_sendTransaction',
            params: [{ from: walletAddress, to: ctfAddr, data: approveData }],
          });
          let receipt = null;
          while (!receipt) {
            await new Promise(r => setTimeout(r, 2000));
            receipt = await window.ethereum.request({ method: 'eth_getTransactionReceipt', params: [approveTx] });
          }
          if (receipt.status !== '0x1') throw new Error(`Approval failed on ${CHAIN_NAME[chainId]}`);
        }
      }
    }

    // Phase 2: Fire sell orders sequentially
    setTxStep('batch_selling');
    const sellOrders = [];
    for (let i = 0; i < positions.length; i++) {
      const p = positions[i];
      const plName = (PLATFORMS[p.platform] || {}).name || p.platform;
      setTxMsg(`Selling on ${plName} (${i + 1}/${positions.length})...`);

      const resp = await fetch('/api/sell', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ order_id: p.order_id, amount: p.shares, to_chain: toChainId }),
      });
      const sellOrder = await resp.json();
      if (sellOrder.error) {
        setTxMsg(`${plName}: ${sellOrder.error}`);
        await new Promise(r => setTimeout(r, 1000));
        continue; // skip failed, proceed with others
      }
      sellOrders.push({ ...sellOrder, platformName: plName });
      // Small delay between calls to avoid nonce collisions
      if (i < positions.length - 1) await new Promise(r => setTimeout(r, 500));
    }

    if (sellOrders.length === 0) {
      setTxFailed('batch_selling', 'All sell orders failed');
      return;
    }

    // Phase 3: Poll all sell orders until all complete
    setTxStep('batch_settling');
    const pending = new Set(sellOrders.map(o => o.id));
    let totalProceeds = 0;
    let totalShares = 0;

    while (pending.size > 0) {
      await new Promise(r => setTimeout(r, 5000));

      for (const so of sellOrders) {
        if (!pending.has(so.id)) continue;
        try {
          const st = await fetch(`/api/order/${so.id}`).then(r => r.json());

          if (st.status === 'sell_settled' || st.status === 'bridging_back') {
            setTxStep('batch_bridging');
          }

          if (st.status === 'completed') {
            const dec = PLATFORM_DECIMALS[positions.find(p => p.order_id === so.buy_order_id)?.platform] || 6;
            totalProceeds += (st.settle_results?.proceeds || 0) / (10 ** dec);
            totalShares += (st.shares_amount || 0) / (10 ** dec);
            pending.delete(so.id);
          } else if (st.status === 'trade_failed' || st.status === 'bridge_failed') {
            pending.delete(so.id);
          }
        } catch {}
      }

      // Update message with progress
      const done = sellOrders.length - pending.size;
      setTxMsg(`${done}/${sellOrders.length} orders complete...`);
    }

    // Done
    const msg = totalProceeds > 0
      ? `Sold ${totalShares.toFixed(2)} shares across ${sellOrders.length} platforms → $${totalProceeds.toFixed(2)} USDC`
      : `Sold across ${sellOrders.length} platforms`;
    setTxDone(msg);
    loadPositions();
    fetchBalance();

  } catch (e) {
    setTxFailed('batch_approving', e.message || String(e));
  }
}

// --- Balance ---
async function fetchBalance() {
  if (!walletAddress || !window.ethereum) { userBalance = null; return; }
  try {
    const data = '0x70a08231' + walletAddress.slice(2).toLowerCase().padStart(64, '0');
    const hex = await window.ethereum.request({
      method: 'eth_call',
      params: [{ to: USDC_ADDRESS, data }, 'latest'],
    });
    userBalance = hex && hex.length > 2 ? Number(BigInt(hex)) / 1e6 : 0;
  } catch { userBalance = null; }
  renderKeepScroll();
}

// --- Buy flow ---
const USDC_ADDRESS = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913';
const BASE_CHAIN_ID = '0x2105'; // 8453

// Stablecoin per chain
const CHAIN_STABLE = {
  8453: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC on Base
  137:  '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174', // USDC.e on Polygon
  56:   '0x55d398326f99059fF775485246999027B3197955', // USDT on BSC
};
const CHAIN_DECIMALS = { 8453: 6, 137: 6, 56: 18 };

async function submitOrder(fromChainId) {
  if (!walletAddress) { alert('Connect wallet first'); return; }
  if (!routeResult || routeResult.total_spent <= 0) { alert('Enter amount first'); return; }

  const o = event.outcomes[selectedOutcome];
  const budget = routeResult.total_spent;
  const cfg = await fetch('/api/config').then(r => r.json());
  const chainRouters = cfg.chain_routers || {};
  const routerAddr = chainRouters[String(fromChainId)] || cfg.router_address;
  if (!routerAddr) { alert('Router not configured'); return; }

  // Detect all target chains from route
  const targetChains = new Set();
  if (routeResult.per_platform) {
    for (const p of Object.keys(routeResult.per_platform)) {
      targetChains.add(PLATFORMS[p]?.chain || 0);
    }
  }
  const sameChain = targetChains.size > 0 && [...targetChains].every(c => c === fromChainId);
  const bridgeChainLabel = [...targetChains].filter(c => c !== fromChainId).map(c => CHAIN_NAME[c] || c).join(' & ') || 'target chain';
  const fromChainHex = CHAIN_HEX[fromChainId] || '0x2105';
  const fromScan = CHAIN_SCAN[fromChainId] || 'basescan.org';
  const stableAddr = CHAIN_STABLE[fromChainId] || USDC_ADDRESS;
  const stableDec = CHAIN_DECIMALS[fromChainId] || 6;
  // Always approve Router on the source chain
  const spenderAddr = routerAddr;

  openTxModal('buy', sameChain, bridgeChainLabel);
  setTxStep('approving');

  try {
    // Switch to source chain
    const chainId = await window.ethereum.request({ method: 'eth_chainId' });
    if (chainId !== fromChainHex) {
      await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: fromChainHex }] });
    }

    // Check existing allowance
    const allowanceData = '0xdd62ed3e' +
      walletAddress.slice(2).toLowerCase().padStart(64, '0') +
      spenderAddr.slice(2).toLowerCase().padStart(64, '0');
    const allowanceHex = await window.ethereum.request({
      method: 'eth_call',
      params: [{ to: stableAddr, data: allowanceData }, 'latest'],
    });
    const allowance = allowanceHex && allowanceHex.length > 2 ? BigInt(allowanceHex) : 0n;
    const needed = BigInt(Math.round(budget * (10 ** stableDec)));

    let approveTx = null;
    if (allowance >= needed) {
      setTxStep('approved');
      setTxMsg('Already approved');
    } else {
      const approveData = '0x095ea7b3' +
        spenderAddr.slice(2).toLowerCase().padStart(64, '0') +
        needed.toString(16).padStart(64, '0');

      approveTx = await window.ethereum.request({
        method: 'eth_sendTransaction',
        params: [{ from: walletAddress, to: stableAddr, data: approveData }],
      });

      setTxMsg('Waiting for confirmation…');

      let receipt = null;
      while (!receipt) {
        await new Promise(r => setTimeout(r, 2000));
        receipt = await window.ethereum.request({
          method: 'eth_getTransactionReceipt',
          params: [approveTx],
        });
      }

      if (receipt.status !== '0x1') { setTxFailed('approving', 'Approve transaction reverted'); return; }

      setTxStep('approved');
      setTxScanLink('approved', `https://${fromScan}/tx/${approveTx}`);
    }

    // Relay via backend
    setTxStep('relaying');
    const eventId = new URLSearchParams(location.search).get('id') || event.id;
    const resp = await fetch('/api/order', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        wallet: walletAddress,
        event_id: eventId,
        team: o.name,
        side: selectedSide,
        budget: budget,
        route: routeResult,
        approve_tx_hash: approveTx,
        from_chain: fromChainId,
      }),
    });
    const order = await resp.json();

    if (order.status !== 'sent' && order.status !== 'bridged') {
      setTxFailed('relaying', order.error || 'Relay failed');
      return;
    }

    if (!sameChain) {
      setTxStep('sent');
      setTxScanLink('sent', `https://${fromScan}/tx/${order.tx_hash}`);
      setTxStep('bridging');
      setTxMsg('Waiting for bridge confirmation…');
    } else {
      const txScan = CHAIN_SCAN[fromChainId] || 'basescan.org';
      setTxScanLink('relaying', `https://${txScan}/tx/${order.tx_hash}`);
      setTxMsg('Transferred, placing orders…');
    }

    let settled = false;
    while (!settled) {
      await new Promise(r => setTimeout(r, 5000));
      const st = await fetch(`/api/order/${order.id}`).then(r => r.json());

      // Multi-bridge progress: count done/total from st.bridges
      if (st.status === 'sent' && st.bridges) {
        const entries = Object.values(st.bridges);
        const total = entries.length;
        const done = entries.filter(b => b.status === 'done').length;
        if (total > 1) {
          setTxMsg(`Bridging ${done} of ${total}…`);
        }
      } else if (st.status === 'bridged') {
        if (st.receiving_tx_hash && st.receiving_chain_id) {
          const scan = st.receiving_chain_id === 137 ? 'polygonscan.com' : 'basescan.org';
          setTxScanLink('bridging', `https://${scan}/tx/${st.receiving_tx_hash}`);
        }
        setTxStep('trading');
        // Multi-platform trade progress
        const platCount = Object.keys(st.platforms || {}).length;
        const tradeDone = Object.keys(st.trade_results || {}).length;
        if (platCount > 1) {
          setTxMsg(`Placing orders ${tradeDone} of ${platCount}…`);
        } else {
          setTxMsg('Placing orders on markets…');
        }
      } else if (st.status === 'matched') {
        setTxStep('settling');
        const platCount = Object.keys(st.platforms || {}).length;
        const transferDone = Object.keys(st.transfer_results || {}).length;
        if (platCount > 1) {
          setTxMsg(`Delivering shares ${transferDone} of ${platCount}…`);
        } else {
          setTxMsg('Waiting for settlement & transferring shares…');
        }
      } else if (st.status === 'filled') {
        // Build result summary
        let sharesTotal = 0;
        const platCount = Object.keys(st.platforms || {}).length;
        if (st.transfer_results) {
          const txs = Object.entries(st.transfer_results);
          for (const [pname, t] of txs) {
            if (t.tx_hash) {
              const dec = PLATFORM_DECIMALS[pname] || 6;
              sharesTotal += (t.amount || 0) / (10 ** dec);
              const scan = CHAIN_SCAN[PLATFORMS[pname]?.chain] || 'basescan.org';
              setTxScanLink('settling', `https://${scan}/tx/${t.tx_hash}`);
            }
          }
        }
        const spent = st.budget || 0;
        const msg = sharesTotal > 0
          ? `Spent $${spent.toFixed(2)} → ${sharesTotal.toFixed(2)} shares` + (platCount > 1 ? ` across ${platCount} platforms` : '')
          : 'Shares delivered to your wallet';
        setTxDone(msg);
        settled = true;
        loadPositions();
        fetchBalance();
      } else if (st.status === 'failed') {
        setTxFailed('bridging', 'Bridge failed');
        settled = true;
      } else if (st.status === 'trade_failed') {
        setTxFailed('trading', st.trade_error || 'Order execution failed');
        settled = true;
      }
    }
  } catch (e) {
    setTxFailed('approving', e.message || String(e));
  }
}

// --- Test Batch Buy ---
async function testBatch() {
  if (!walletAddress) { alert('Connect wallet first'); return; }
  const amount = parseFloat(document.getElementById('testBatchAmount').value) || 6;
  const eventId = new URLSearchParams(location.search).get('id') || event.id;
  const o = event.outcomes[selectedOutcome || 0];
  const team = o.name;
  const side = selectedSide || 'yes';

  try {
    const resp = await fetch('/api/test_batch_route', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ budget: amount, event_id: eventId, team, side }),
    });
    routeResult = await resp.json();
    if (routeResult.error) { alert('Route error: ' + routeResult.error); return; }
    if (routeResult.total_spent <= 0) { alert('No liquidity on platforms'); return; }
    renderKeepScroll();
    // Trigger buy from BSC (chain 56)
    submitOrder(56);
  } catch (e) {
    alert('Test batch failed: ' + e.message);
  }
}

init();

// Wallet connection (global for tx-modal.js access)
var walletAddress = null;
window.walletAddress = null;

function shortAddr(addr) {
  return addr.slice(0, 6) + '...' + addr.slice(-4);
}

function updateWalletBtn() {
  const btn = document.getElementById('walletBtn');
  if (walletAddress) {
    btn.textContent = shortAddr(walletAddress);
    btn.classList.add('connected');
  } else {
    btn.textContent = 'Connect Wallet';
    btn.classList.remove('connected');
  }
}

async function connectWallet() {
  if (walletAddress) return;
  if (!window.ethereum) {
    alert('No wallet found. Install MetaMask or another wallet.');
    return;
  }
  try {
    // Force account picker to open
    await window.ethereum.request({ method: 'wallet_requestPermissions', params: [{ eth_accounts: {} }] });
    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
    walletAddress = accounts[0];
    localStorage.setItem('walletAddress', walletAddress);
    updateWalletBtn();
    fetchBalance();
  } catch (e) {
    console.error('Wallet connect failed:', e);
  }
}

(function restoreWallet() {
  const saved = localStorage.getItem('walletAddress');
  if (saved) {
    walletAddress = saved;
    updateWalletBtn();
    fetchBalance();
  }
  if (window.ethereum) {
    window.ethereum.on('accountsChanged', (accounts) => {
      walletAddress = accounts[0] || null;
      if (walletAddress) localStorage.setItem('walletAddress', walletAddress);
      else localStorage.removeItem('walletAddress');
      updateWalletBtn();
      fetchBalance();
    });
  }
})();
</script>
<script src="/static/tx-modal.js"></script>
<script src="/static/wallet-dropdown.js"></script>
</body>
</html>
